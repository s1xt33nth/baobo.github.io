<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DDD 基础</title>
    <url>/2019/10/16/DDD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="DDD-基础"><a href="#DDD-基础" class="headerlink" title="DDD 基础"></a>DDD 基础</h1><h2 id="领域和子域"><a href="#领域和子域" class="headerlink" title="领域和子域"></a>领域和子域</h2><p>领域就是用来确定范围的，范围即边界，这也是 DDD 在设计中不断强调边界的原因。</p>
<a id="more"></a>

<p>在研究和解决业务问题时，DDD 会按照一定的规则<strong>将业务领域进行细分</strong>，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，DDD 的领域就是这个边界内要解决的业务问题域。</p>
<p>既然领域是用来限定业务边界和范围的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。</p>
<p>领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。</p>
<p>不同行业的业务模型可能会不一样，但领域建模和微服务建设的过程和方法基本类似，其核心思想就是<strong>将问题域逐步分解</strong>，<strong>降低业务理解和系统实现的复杂度</strong>。</p>
<h2 id="核心域、通用域和支撑域"><a href="#核心域、通用域和支撑域" class="headerlink" title="核心域、通用域和支撑域"></a>核心域、通用域和支撑域</h2><p>在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。</p>
<ul>
<li><p>决定产品和公司核心竞争力的子域是<strong>核心域</strong>，它是业务成功的主要因素和公司的核心竞争力。</p>
</li>
<li><p>没有太多个性化的诉求，同时被多个子域使用的通用功能子域是<strong>通用域</strong>。</p>
</li>
<li><p>还有一种功能子域是必须的，但既不包含决定产品 / 和公司核心竞争力 / 的功能，也不包含通用功能的子域，它就是<strong>支撑域</strong>。</p>
</li>
</ul>
<h2 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h2><p>在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是<strong>通用语言</strong>。也就是说，通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。</p>
<p>那么，通用语言的价值也就很明了了，它可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。</p>
<h2 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h2><p>我们知道语言都有它的语义环境，同样，通用语言也有它的上下文环境。为了避免同样的概念或语义在不同的上下文环境中产生歧义，DDD 在战略设计上提出了 “<strong>限界上下文</strong>” 这个概念，用来确定语义所在的领域边界。</p>
<p>我们可以将限界上下文拆解为两个词：<strong>限界</strong>和<strong>上下文</strong>。限界就是领域的边界，而上下文则是语义环境。通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流。</p>
<p> 综合一下，我认为限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。 </p>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p> 在 DDD 中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为<strong>实体</strong>。 </p>
<p> 在领域模型映射到数据模型时，一个实体可能对应 <strong>0 个、1 个或者多个</strong>数据库持久化对象。大多数情况下实体与持久化对象是一对一。在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。 </p>
<h2 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h2><p> 通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作<strong>值对象</strong>。 </p>
<p> 也就说，值对象描述了领域中的一件东西，这个东西是不可变的，它将不同的相关属性组合成了一个概念整体。当度量和描述改变时，可以用另外一个值对象予以替换。它可以和其它值对象进行相等性比较，且不会对协作对象造成副作用。 </p>
<p>值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是<strong>属性嵌入</strong>的方式和<strong>序列化大对象</strong>的方式。</p>
<p>引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。比如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。</p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是<strong>聚合</strong>，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。 </p>
<p>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。 </p>
<h2 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h2><p> 如果把聚合比作组织，那<strong>聚合根</strong>就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>聚合</strong>的特点：高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位，但我不建议你对微服务过度拆分。但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。</p>
<p>一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了。</p>
<p><strong>聚合根</strong>的特点：聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。</p>
<p><strong>实体</strong>的特点：有 ID 标识，通过 ID 判断相等性，ID 在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。</p>
<p><strong>值对象</strong>的特点：无 ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 代码模型</title>
    <url>/2019/10/16/DDD%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="DDD-代码模型"><a href="#DDD-代码模型" class="headerlink" title="DDD 代码模型"></a>DDD 代码模型</h1><h2 id="DDD-分层架构与微服务代码模型"><a href="#DDD-分层架构与微服务代码模型" class="headerlink" title="DDD 分层架构与微服务代码模型"></a>DDD 分层架构与微服务代码模型</h2><p>我们参考 DDD 分层架构模型来设计微服务代码模型。没错！微服务代码模型就是依据 DDD 分层架构模型设计出来的。那为什么是 DDD 分层架构模型呢？</p>
<a id="more"></a>

<p><img src="https://static001.geekbang.org/resource/image/a3/01/a308123994f87a5ce99adc85dd9b4d01.jpg" alt="img"></p>
<ul>
<li><p>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</p>
</li>
<li><p>应用层职责：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的功能。</p>
</li>
<li><p>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。</p>
</li>
<li><p>基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</p>
</li>
</ul>
<p>业务逻辑从领域层、应用层到用户接口层逐层封装和协作，对外提供灵活的服务，既实现了各层的分工，又实现了各层的协作。因此，毋庸置疑，DDD 分层架构模型就是设计微服务代码模型的最佳依据。</p>
<h2 id="微服务代码模型"><a href="#微服务代码模型" class="headerlink" title="微服务代码模型"></a>微服务代码模型</h2><p>现在，我们来看一下，按照 DDD 分层架构模型设计出来的微服务代码模型到底长什么样子呢？</p>
<p>其实，DDD 并没有给出标准的代码模型，不同的人可能会有不同理解。下面要说的这个微服务代码模型是我经过思考和实践后建立起来的，主要考虑的是微服务的边界、分层以及架构演进。</p>
<h3 id="微服务一级目录结构"><a href="#微服务一级目录结构" class="headerlink" title="微服务一级目录结构"></a>微服务一级目录结构</h3><p>微服务一级目录是按照 DDD 分层架构的分层职责来定义的。从下面这张图中，我们可以看到，在代码模型里分别为用户接口层、应用层、领域层和基础层，建立了 interfaces、application、domain 和 infrastructure 四个一级代码目录。</p>
<p><img src="https://static001.geekbang.org/resource/image/d1/71/d1bea7dc6bd93f3bd30ced821f36bb71.jpg" alt="img"></p>
<p>这些目录的职能和代码形态是这样的。</p>
<ul>
<li><p>Interfaces（用户接口层）：它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。</p>
</li>
<li><p>Application（应用层）：它主要存放应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。</p>
</li>
<li><p>Domain（领域层）：它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里。</p>
</li>
<li><p>Infrastructure（基础层）：它主要存放基础资源服务相关的代码，为其它各层提供的通用技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里。</p>
</li>
</ul>
<h3 id="各层目录结构"><a href="#各层目录结构" class="headerlink" title="各层目录结构"></a>各层目录结构</h3><ol>
<li>用户接口层</li>
</ol>
<p>Interfaces 的代码目录结构有：assembler、dto 和 façade 三类。</p>
<p><img src="https://static001.geekbang.org/resource/image/c6/ef/c6ea040a520c91dfe6400f206ff36fef.jpg" alt="img"></p>
<ul>
<li><p>Assembler：实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。</p>
</li>
<li><p>Dto：它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离。</p>
</li>
<li><p>Facade：提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。</p>
</li>
</ul>
<ol start="2">
<li>应用层</li>
</ol>
<p>Application 的代码目录结构有：event 和 service。</p>
<p><img src="https://static001.geekbang.org/resource/image/30/61/30caee3ceaf1085b7aa2cc388f996e61.jpg" alt="img"></p>
<ul>
<li>Event（事件）：这层目录主要存放事件相关的代码。它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。</li>
</ul>
<p>这里提示一下：虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。</p>
<ul>
<li>Service（应用服务）：这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。</li>
</ul>
<ol start="3">
<li>领域层</li>
</ol>
<p>Domain 是由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合内的代码模型是标准和统一的，包括：entity、event、repository 和 service 四个子目录。</p>
<p><img src="https://static001.geekbang.org/resource/image/68/2c/688dd55b8399779baff8fc5b7c124c2c.jpg" alt="img"></p>
<p>而领域层聚合内部的代码目录结构是这样的。</p>
<ul>
<li>Aggregate（聚合）：它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。</li>
</ul>
<p>以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组。聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服务重组，在微服务架构演进中有着很重要的作用。</p>
<ul>
<li><p>Entity（实体）：它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。</p>
</li>
<li><p>Event（事件）：它存放事件实体以及与事件活动相关的业务逻辑代码。</p>
</li>
<li><p>Service（领域服务）：它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用。</p>
</li>
<li><p>Repository（仓储）：它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储。</p>
</li>
</ul>
<p>特别说明：按照 DDD 分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样，如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进。</p>
<ol start="4">
<li>基础层</li>
</ol>
<p>Infrastructure 的代码目录结构有：config 和 util 两个子目录。</p>
<p><img src="https://static001.geekbang.org/resource/image/5b/5a/5bbe3454e2ecf4ff4770e887a4967b5a.jpg" alt="img"></p>
<ul>
<li><p>Config：主要存放配置相关代码。</p>
</li>
<li><p>Util：主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录。</p>
</li>
</ul>
<h3 id="代码模型总目录结构"><a href="#代码模型总目录结构" class="headerlink" title="代码模型总目录结构"></a>代码模型总目录结构</h3><p>在完成一级和二级代码模型设计后，你就可以看到下图这样的微服务代码模型的总目录结构了。</p>
<p><img src="https://static001.geekbang.org/resource/image/91/b8/915ad8d830d925a893cd09ff6cbdadb8.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 分层架构</title>
    <url>/2019/10/16/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="DDD-分层架构"><a href="#DDD-分层架构" class="headerlink" title="DDD 分层架构"></a><strong>DDD 分层架构</strong></h1><h2 id="什么是-DDD-分层架构？"><a href="#什么是-DDD-分层架构？" class="headerlink" title="什么是 DDD 分层架构？"></a>什么是 DDD 分层架构？</h2><p>DDD 的分层架构在不断发展。最早是传统的四层架构；后来四层架构有了进一步的优化，实现了各层对基础层的解耦；再后来领域层和应用层之间增加了上下文环境（Context）层，五层架构（DCI）就此形成了。</p>
<a id="more"></a>

<p><img src="https://static001.geekbang.org/resource/image/d6/e1/d6abc3e4f5837cd51b689d01433cace1.jpg" alt="img"></p>
<p>我们看一下上面这张图，在最早的传统四层架构中，基础层是被其它层依赖的，它位于最核心的位置，那按照分层架构的思想，它应该就是核心，但实际上领域层才是软件的核心，所以这种依赖是有问题的。后来我们采用了依赖倒置（Dependency inversion principle,DIP）的设计，优化了传统的四层架构，实现了各层对基础层的解耦。</p>
<p>在下面这张图中，从上到下依次是：用户接口层、应用层、领域层和基础层。那 DDD 各层的主要职责是什么呢？下面我来逐一介绍一下。</p>
<p><img src="https://static001.geekbang.org/resource/image/a3/01/a308123994f87a5ce99adc85dd9b4d01.jpg" alt="img"></p>
<h3 id="用户接口层"><a href="#用户接口层" class="headerlink" title="用户接口层"></a>用户接口层</h3><p>用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。</p>
<p>此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。</p>
<p>这里我要提醒你一下：在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。因为庞大的应用层会使领域模型失焦，时间一长你的微服务就会演化为传统的三层架构，业务逻辑会变得混乱。</p>
<p>另外，应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布。还有，应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。</p>
<h3 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h3><p>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。</p>
<p>领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。</p>
<p>这里我要特别解释一下其中几个领域对象的关系，以便你在设计领域层的时候能更加清楚。首先，领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能。其次，你要知道，实体和领域对象在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。</p>
<h3 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h3><p>基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p>
<p>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</p>
<p>比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。</p>
<h2 id="DDD-分层架构最重要的原则是什么？"><a href="#DDD-分层架构最重要的原则是什么？" class="headerlink" title="DDD 分层架构最重要的原则是什么？"></a>DDD 分层架构最重要的原则是什么？</h2><p>在《实现领域驱动设计》一书中，DDD 分层架构有一个重要的原则：每层只能与位于其下方的层发生耦合。</p>
<p> 而架构根据耦合的紧密程度又可以分为两种：<strong>严格分层架构</strong>和<strong>松散分层架构</strong>。优化后的 DDD 分层架构模型就属于严格分层架构，任何层只能对位于其直接下方的层产生依赖。而传统的 DDD 分层架构则属于松散分层架构，它允许某层与其任意下方的层发生依赖。 </p>
<h2 id="三层架构如何演进到-DDD-分层架构？"><a href="#三层架构如何演进到-DDD-分层架构？" class="headerlink" title="三层架构如何演进到 DDD 分层架构？"></a>三层架构如何演进到 DDD 分层架构？</h2><p>传统企业应用大多是单体架构，而单体架构则大多是三层架构。三层架构解决了程序内代码间调用复杂、代码职责不清的问题，但这种分层是逻辑概念，在物理上它是中心化的集中式架构，并不适合分布式微服务架构。</p>
<p>DDD 分层架构中的要素其实和三层架构类似，只是在 DDD 分层架构中，这些要素被重新归类，重新划分了层，确定了层与层之间的交互规则和职责边界。</p>
<p><img src="https://static001.geekbang.org/resource/image/16/a1/1680723ca91aa57d719d5cdbc1d910a1.jpg" alt="img"></p>
<p>DDD 分层架构在用户接口层引入了 DTO，给前端提供了更多的可使用数据和更高的展示灵活性。</p>
<p>DDD 分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。DDD 分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。</p>
<p>另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用 DAO 方式；DDD 分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦。</p>
<p>仓储又分为两部分：仓储接口和仓储实现。仓储接口放在领域层中，仓储实现放在基础层。原来三层架构通用的第三方工具包、驱动、Common、Utility、Config 等通用的公共的资源类统一放到了基础层。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 视图</title>
    <url>/2019/10/16/DDD%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="DDD-视图"><a href="#DDD-视图" class="headerlink" title="DDD 视图"></a>DDD 视图</h1><h2 id="服务的协作"><a href="#服务的协作" class="headerlink" title="服务的协作"></a>服务的协作</h2><h3 id="1-服务的类型"><a href="#1-服务的类型" class="headerlink" title="1. 服务的类型"></a>1. 服务的类型</h3><p>我们先来回顾一下分层架构中的服务。按照分层架构设计出来的微服务，其内部有 Facade 服务、应用服务、领域服务和基础服务。各层服务的主要功能和职责如下。</p>
<a id="more"></a>

<p><strong>Facade 服务</strong>：位于用户接口层，包括接口和实现两部分。用于处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将数据传递给应用层。或者在获取到应用层数据后，将 DO 组装成 DTO，将数据传输到前端应用。</p>
<p><strong>应用服务</strong>：位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果拼装，对外提供粗粒度的服务。</p>
<p><strong>领域服务</strong>：位于领域层。领域服务封装核心的业务逻辑，实现需要多个实体协作的核心领域逻辑。它对多个实体或方法的业务逻辑进行组合或编排，或者在严格分层架构中对实体方法进行封装，以领域服务的方式供应用层调用。</p>
<p><strong>基础服务</strong>：位于基础层。提供基础资源服务（比如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务应用逻辑的影响。基础服务主要为仓储服务，通过依赖倒置提供基础资源服务。领域服务和应用服务都可以调用仓储服务接口，通过仓储服务实现数据持久化。</p>
<h3 id="2-服务的调用"><a href="#2-服务的调用" class="headerlink" title="2. 服务的调用"></a>2. 服务的调用</h3><p>我们看一下下面这张图。微服务的服务调用包括三类主要场景：微服务内跨层服务调用，微服务之间服务调用和领域事件驱动。</p>
<p><img src="https://static001.geekbang.org/resource/image/e5/db/e5d025a6fd69d1f2cf2a1af53253abdb.png" alt="img"></p>
<h4 id="微服务内跨层服务调用"><a href="#微服务内跨层服务调用" class="headerlink" title="微服务内跨层服务调用"></a>微服务内跨层服务调用</h4><p>微服务架构下往往采用前后端分离的设计模式，前端应用独立部署。前端应用调用发布在 API 网关上的 Facade 服务，Facade 定向到应用服务。应用服务作为服务组织和编排者，它的服务调用有这样两种路径：</p>
<ul>
<li><p>第一种是应用服务调用并组装领域服务。此时领域服务会组装实体和实体方法，实现核心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。</p>
</li>
<li><p>第二种是应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象。</p>
</li>
</ul>
<h4 id="微服务之间的服务调用"><a href="#微服务之间的服务调用" class="headerlink" title="微服务之间的服务调用"></a>微服务之间的服务调用</h4><p>微服务之间的应用服务可以直接访问，也可以通过 API 网关访问。由于跨微服务操作，在进行数据新增和修改操作时，你需关注分布式事务，保证数据的一致性。</p>
<h4 id="领域事件驱动"><a href="#领域事件驱动" class="headerlink" title="领域事件驱动"></a>领域事件驱动</h4><p>领域事件驱动包括微服务内和微服务之间的事件（详见 [第 06 讲]）。微服务内通过事件总线（EventBus）完成聚合之间的异步处理。微服务之间通过消息中间件完成。异步化的领域事件驱动机制是一种间接的服务访问方式。</p>
<p>当应用服务业务逻辑处理完成后，如果发生领域事件，可调用事件发布服务，完成事件发布。</p>
<p>当接收到订阅的主题数据时，事件订阅服务会调用事件处理领域服务，完成进一步的业务操作。</p>
<h3 id="3-服务的封装与组合"><a href="#3-服务的封装与组合" class="headerlink" title="3. 服务的封装与组合"></a>3. 服务的封装与组合</h3><p>我们看一下下面这张图。微服务的服务是从领域层逐级向上封装、组合和暴露的。</p>
<p><img src="https://static001.geekbang.org/resource/image/2d/1d/2d6a328a9fd8b4b3906bb9f59435ca1d.png" alt="img"></p>
<h4 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h4><p>基础层的服务形态主要是仓储服务。仓储服务包括接口和实现两部分。仓储接口服务供应用层或者领域层服务调用，仓储实现服务，完成领域对象的持久化或数据初始化。</p>
<h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层实现核心业务逻辑，负责表达领域模型业务概念、业务状态和业务规则。主要的服务形态有实体方法和领域服务。</p>
<p>实体采用充血模型，在实体类内部实现实体相关的所有业务逻辑，实现的形式是实体类中的方法。实体是微服务的原子业务逻辑单元。在设计时我们主要考虑实体自身的属性和业务行为，实现领域模型的核心基础能力。不必过多考虑外部操作和业务流程，这样才能保证领域模型的稳定性。</p>
<p>DDD 提倡富领域模型，尽量将业务逻辑归属到实体对象上，实在无法归属的部分则设计成领域服务。领域服务会对多个实体或实体方法进行组装和编排，实现跨多个实体的复杂核心业务逻辑。</p>
<p>对于严格分层架构，如果单个实体的方法需要对应用层暴露，则需要通过领域服务封装后才能暴露给应用服务。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，负责不同聚合之间的服务和数据协调，负责微服务之间的事件发布和订阅。</p>
<p>通过应用服务对外暴露微服务的内部功能，这样就可以隐藏领域层核心业务逻辑的复杂性以及内部实现机制。应用层的主要服务形态有：应用服务、事件发布和订阅服务。</p>
<p>应用服务内用于组合和编排的服务，主要来源于领域服务，也可以是外部微服务的应用服务。除了完成服务的组合和编排外，应用服务内还可以完成安全认证、权限校验、初步的数据校验和分布式事务控制等功能。</p>
<p>为了实现微服务内聚合之间的解耦，聚合之间的服务调用和数据交互应通过应用服务来完成。原则上我们应该禁止聚合之间的领域服务直接调用和聚合之间的数据表关联。</p>
<h4 id="用户接口层"><a href="#用户接口层" class="headerlink" title="用户接口层"></a>用户接口层</h4><p>用户接口层是前端应用和微服务之间服务访问和数据交换的桥梁。它处理前端发送的 Restful 请求和解析用户输入的配置文件等，将数据传递给应用层。或获取应用服务的数据后，进行数据组装，向前端提供数据服务。主要服务形态是 Facade 服务。</p>
<p>Facade 服务分为接口和实现两个部分。完成服务定向，DO 与 DTO 数据的转换和组装，实现前端与应用层数据的转换和交换。</p>
<h3 id="4-两种分层架构的服务依赖关系"><a href="#4-两种分层架构的服务依赖关系" class="headerlink" title="4. 两种分层架构的服务依赖关系"></a>4. 两种分层架构的服务依赖关系</h3><p>现在我们回顾一下 DDD 分层架构，分层架构有一个重要的原则就是：每层只能与位于其下方的层发生耦合。</p>
<p>那根据耦合的紧密程度，分层架构可以分为两种：严格分层架构和松散分层架构。在严格分层架构中，任何层只能与位于其直接下方的层发生依赖。在松散分层架构中，任何层可以与其任意下方的层发生依赖。</p>
<p>下面我们来详细分析和比较一下这两种分层架构。</p>
<h4 id="松散分层架构的服务依赖"><a href="#松散分层架构的服务依赖" class="headerlink" title="松散分层架构的服务依赖"></a>松散分层架构的服务依赖</h4><p>我们看一下下面这张图，在松散分层架构中，领域层的实体方法和领域服务可以直接暴露给应用层和用户接口层。松散分层架构的服务依赖关系，无需逐级封装，可以快速暴露给上层。</p>
<p>但它存在一些问题，第一个是容易暴露领域层核心业务的实现逻辑；第二个是当实体方法或领域服务发生服务变更时，由于服务同时被多层服务调用和组合，不容易找出哪些上层服务调用和组合了它，不方便通知到所有的服务调用方。</p>
<p><img src="https://static001.geekbang.org/resource/image/5e/a1/5e901b4f7fa964b349e4d6f344786ea1.png" alt="img"></p>
<p>我们再来看一张图，在松散分层架构中，实体 A 的方法在应用层组合后，暴露给用户接口层 aFacade。abDomainService 领域服务直接越过应用层，暴露给用户接口层 abFacade 服务。松散分层架构中任意下层服务都可以暴露给上层服务。</p>
<p><img src="https://static001.geekbang.org/resource/image/b3/a0/b35d6fed54e26423c0d61de040ab04a0.jpeg" alt="img"></p>
<h4 id="严格分层架构的服务依赖"><a href="#严格分层架构的服务依赖" class="headerlink" title="严格分层架构的服务依赖"></a>严格分层架构的服务依赖</h4><p>我们看一下下面这张图，在严格分层架构中，每一层服务只能向紧邻的上一层提供服务。虽然实体、实体方法和领域服务都在领域层，但实体和实体方法只能暴露给领域服务，领域服务只能暴露给应用服务。</p>
<p>在严格分层架构中，服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。</p>
<p>这是因为通过封装你可以避免将核心业务逻辑的实现暴露给外部，将实体和方法封装成领域服务，也可以避免在应用层沉淀过多的本该属于领域层的核心业务逻辑，避免应用层变得臃肿。还有就是当服务发生变更时，由于服务只被紧邻上层的服务调用和组合，你只需要逐级告知紧邻上层就可以了，服务可管理性比松散分层架构要好是一定的。</p>
<p><img src="https://static001.geekbang.org/resource/image/ab/07/ab304d69ee174b5e69cb63d79864ca07.png" alt="img"></p>
<p>我们还是看图，A 实体方法需封装成领域服务 aDomainService 才能暴露给应用服务 aAppService。abDomainService 领域服务组合和封装 A 和 B 实体的方法后，暴露给应用服务 abAppService。</p>
<p><img src="https://static001.geekbang.org/resource/image/34/f9/348d60eac28c9dbf7d120d1b7159cdf9.png" alt="img"></p>
<h2 id="数据对象视图"><a href="#数据对象视图" class="headerlink" title="数据对象视图"></a>数据对象视图</h2><p>在 DDD 中有很多的数据对象，这些对象分布在不同的层里。它们在不同的阶段有不同的形态。</p>
<p>我们先来看一下微服务内有哪些类型的数据对象？它们是如何协作和转换的？</p>
<ul>
<li><p>数据持久化对象 PO(Persistent Object)，与数据库结构一一映射，是数据持久化过程中的数据载体。</p>
</li>
<li><p>领域对象 DO（Domain Object），微服务运行时的实体，是核心业务的载体。</p>
</li>
<li><p>数据传输对象 DTO（Data Transfer Object），用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。</p>
</li>
<li><p>视图对象 VO（View Object），用于封装展示层指定页面或组件的数据。</p>
</li>
</ul>
<p>我们结合下面这张图，看看微服务各层数据对象的职责和转换过程。</p>
<p><img src="https://static001.geekbang.org/resource/image/95/73/95524b08051fcd181e65f825005a4c73.png" alt="img"></p>
<h4 id="基础层-1"><a href="#基础层-1" class="headerlink" title="基础层"></a>基础层</h4><p>基础层的主要对象是 PO 对象。我们需要先建立 DO 和 PO 的映射关系。当 DO 数据需要持久化时，仓储服务会将 DO 转换为 PO 对象，完成数据库持久化操作。当 DO 数据需要初始化时，仓储服务从数据库获取数据形成 PO 对象，并将 PO 转换为 DO，完成数据初始化。</p>
<p>大多数情况下 PO 和 DO 是一一对应的。但也有 DO 和 PO 多对多的情况，在 DO 和 PO 数据转换时，需要进行数据重组。</p>
<h4 id="领域层-1"><a href="#领域层-1" class="headerlink" title="领域层"></a>领域层</h4><p>领域层的主要对象是 DO 对象。DO 是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑。通过 DO 和 PO 转换，我们可以完成数据持久化和初始化。</p>
<h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><p>应用层的主要对象是 DO 对象。如果需要调用其它微服务的应用服务，DO 会转换为 DTO，完成跨微服务的数据组装和传输。用户接口层先完成 DTO 到 DO 的转换，然后应用服务接收 DO 进行业务处理。如果 DTO 与 DO 是一对多的关系，这时就需要进行 DO 数据重组。</p>
<h4 id="用户接口层-1"><a href="#用户接口层-1" class="headerlink" title="用户接口层"></a>用户接口层</h4><p>用户接口层会完成 DO 和 DTO 的互转，完成微服务与前端应用数据交互及转换。Facade 服务会对多个 DO 对象进行组装，转换为 DTO 对象，向前端应用完成数据转换和传输。</p>
<h4 id="前端应用"><a href="#前端应用" class="headerlink" title="前端应用"></a>前端应用</h4><p>前端应用主要是 VO 对象。展现层使用 VO 进行界面展示，通过用户接口层与应用层采用 DTO 对象进行数据交互。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 边界</title>
    <url>/2019/10/16/DDD%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<h1 id="DDD-边界"><a href="#DDD-边界" class="headerlink" title="DDD 边界"></a>DDD 边界</h1><h2 id="微服务边界的作用"><a href="#微服务边界的作用" class="headerlink" title="微服务边界的作用"></a>微服务边界的作用</h2><p>你应该还记得 DDD 设计方法里的限界上下文和聚合吧？它们就是用来定义领域模型和微服务边界的。</p>
<p>我们再来回顾一下 DDD 的设计过程。</p>
<a id="more"></a>

<p>在事件风暴中，我们会梳理出业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出实体等领域对象。根据实体对象之间的业务关联性，将业务紧密相关的多个实体进行组合形成聚合，聚合之间是第一层边界。根据业务及语义边界等因素将一个或者多个聚合划定在一个限界上下文内，形成领域模型，限界上下文之间的边界是第二层边界。</p>
<p>为了方便理解，我们将这些边界分为：<strong>逻辑边界</strong>、<strong>物理边界</strong>和<strong>代码边界</strong>。</p>
<p><strong>逻辑边界</strong>主要定义同一业务领域或应用内紧密关联的对象所组成的不同聚类的组合之间的边界。事件风暴对不同实体对象进行关联和聚类分析后，会产生多个聚合和限界上下文，它们一起组成这个领域的领域模型。微服务内聚合之间的边界就是逻辑边界。一般来说微服务会有一个以上的聚合，在开发过程中不同聚合的代码隔离在不同的聚合代码目录中。</p>
<p>逻辑边界在微服务设计和架构演进中具有非常重要的意义！</p>
<p>微服务的架构演进并不是随心所欲的，需要遵循一定的规则，这个规则就是逻辑边界。微服务架构演进时，在业务端以聚合为单位进行业务能力的重组，在微服务端以聚合的代码目录为单位进行微服务代码的重组。由于按照 DDD 方法设计的微服务逻辑边界清晰，业务高内聚，聚合之间代码松耦合，因此在领域模型和微服务代码重构时，我们就不需要花费太多的时间和精力了。</p>
<p>现在我们来看一个微服务实例，在下面这张图中，我们可以看到微服务里包含了两个聚合的业务逻辑，两个聚合分别内聚了各自不同的业务能力，聚合内的代码分别归到了不同的聚合目录下。</p>
<p>那随着业务的快速发展，如果某一个微服务遇到了高性能挑战，需要将部分业务能力独立出去，我们就可以以聚合为单位，将聚合代码拆分独立为一个新的微服务，这样就可以很容易地实现微服务的拆分。</p>
<p><img src="https://static001.geekbang.org/resource/image/88/3d/88d709569367264d368b08a7d9658c3d.png" alt="img"></p>
<p>另外，我们也可以对多个微服务内有相似功能的聚合进行功能和代码重组，组合为新的聚合和微服务，独立为通用微服务。现在你是不是有点做中台的感觉呢？</p>
<p><strong>物理边界</strong>主要从部署和运行的视角来定义微服务之间的边界。不同微服务部署位置和运行环境是相互物理隔离的，分别运行在不同的进程中。这种边界就是微服务之间的物理边界。</p>
<p><strong>代码边界</strong>主要用于微服务内的不同职能代码之间的隔离。微服务开发过程中会根据代码模型建立相应的代码目录，实现不同功能代码的隔离。由于领域模型与代码模型的映射关系，代码边界直接体现出业务边界。代码边界可以控制代码重组的影响范围，避免业务和服务之间的相互影响。微服务如果需要进行功能重组，只需要以聚合代码为单位进行重组就可以了。</p>
<h2 id="正确理解微服务的边界"><a href="#正确理解微服务的边界" class="headerlink" title="正确理解微服务的边界"></a>正确理解微服务的边界</h2><p>从上述内容中，我们知道了，按照 DDD 设计出来的逻辑边界和代码边界，让微服务架构演进变得不那么费劲了。</p>
<p>微服务的拆分可以参考领域模型，也可以参考聚合，因为聚合是可以拆分为微服务的最小单位的。但实施过程是否一定要做到逻辑边界与物理边界一致性呢？也就是说聚合是否也一定要设计成微服务呢？答案是不一定的，这里就涉及到微服务过度拆分的问题了。</p>
<p>微服务的过度拆分会使软件维护成本上升，比如：集成成本、发布成本、运维成本以及监控和定位问题的成本等。在项目建设初期，如果你不具备较强的微服务管理能力，那就不宜将微服务拆分过细。当我们具备一定的能力以后，且微服务内部的逻辑和代码边界也很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进了。</p>
<p>当然，还要记住一点，微服务内聚合之间的服务调用和数据依赖需要符合高内聚松耦合的设计原则和开发规范，否则你也不能很快完成微服务的架构演进。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们主要讨论了微服务架构设计中的各种边界在架构演进中的作用。</p>
<ul>
<li><p>逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。</p>
</li>
<li><p>物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。</p>
</li>
<li><p>代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。</p>
</li>
</ul>
<p>通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 进阶</title>
    <url>/2019/10/16/DDD%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="DDD-进阶"><a href="#DDD-进阶" class="headerlink" title="DDD 进阶"></a>DDD 进阶</h1><h2 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h2><p> 这种事件发生后通常会导致进一步的业务操作，在 DDD 中这种事件被称为领域事件。 </p>
<a id="more"></a>

<h2 id="领域事件总体架构"><a href="#领域事件总体架构" class="headerlink" title="领域事件总体架构"></a>领域事件总体架构</h2><p>  领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等。 </p>
<p><img src="https://static001.geekbang.org/resource/image/b2/8f/b221ed4011c23720ebe9f48ba8eee38f.jpg" alt="img"> </p>
<h3 id="1-事件构建和发布"><a href="#1-事件构建和发布" class="headerlink" title="1. 事件构建和发布"></a>1. 事件构建和发布</h3><p>事件基本属性至少包括：事件唯一标识、发生时间、事件类型和事件源，其中事件唯一标识应该是全局唯一的，以便事件能够无歧义地在多个限界上下文中传递。事件基本属性主要记录事件自身以及事件发生背景的数据。</p>
<p>另外事件中还有一项更重要，那就是业务属性，用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。</p>
<p>事件基本属性和业务属性一起构成事件实体，事件实体依赖聚合根。领域事件发生后，事件中的业务数据不再修改，因此业务数据可以以序列化值对象的形式保存，这种存储格式在消息中间件中也比较容易解析和获取。</p>
<p>为了保证事件结构的统一，我们还会创建事件基类 DomainEvent（参考下图），子类可以扩充属性和方法。由于事件没有太多的业务行为，实现方法一般比较简单。</p>
<p><img src="https://static001.geekbang.org/resource/image/1e/89/1eabec534f268361737e62cd48978289.jpg" alt="img"></p>
<p>事件发布之前需要先构建事件实体并持久化。事件发布的方式有很多种，你可以通过应用服务或者领域服务发布到事件总线或者消息中间件，也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据，发布到消息中间件。</p>
<h3 id="2-事件数据持久化"><a href="#2-事件数据持久化" class="headerlink" title="2. 事件数据持久化"></a>2. 事件数据持久化</h3><p>事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。</p>
<p>事件数据持久化有两种方案，在实施过程中你可以根据自己的业务场景进行选择。</p>
<p>持久化到本地业务数据库的事件表中，利用本地事务保证业务和事件数据的一致性。</p>
<p>持久化到共享的事件数据库中。这里需要注意的是：业务数据库和事件数据库不在一个数据库中，它们的数据持久化操作会跨数据库，因此需要分布式事务机制来保证业务和事件数据的强一致性，结果就是会对系统性能造成一定的影响。</p>
<h3 id="3-事件总线-EventBus"><a href="#3-事件总线-EventBus" class="headerlink" title="3. 事件总线 (EventBus)"></a>3. 事件总线 (EventBus)</h3><p>事件总线是实现微服务内聚合之间领域事件的重要组件，它提供事件分发和接收等服务。事件总线是进程内模型，它会在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据。事件分发流程大致如下：</p>
<p>如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；</p>
<p>如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件；</p>
<p>如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件。</p>
<h3 id="4-消息中间件"><a href="#4-消息中间件" class="headerlink" title="4. 消息中间件"></a>4. 消息中间件</h3><p>跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。消息中间件的产品非常成熟，市场上可选的技术也非常多，比如 Kafka，RabbitMQ 等。</p>
<h3 id="5-事件接收和处理"><a href="#5-事件接收和处理" class="headerlink" title="5. 事件接收和处理"></a>5. 事件接收和处理</h3><p>微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动模型介绍</title>
    <url>/2019/10/16/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="领域驱动模型（Domain-Driven-Design）"><a href="#领域驱动模型（Domain-Driven-Design）" class="headerlink" title="领域驱动模型（Domain Driven Design）"></a>领域驱动模型（Domain Driven Design）</h1><h1 id="什么是领域驱动模型"><a href="#什么是领域驱动模型" class="headerlink" title="什么是领域驱动模型?"></a>什么是领域驱动模型?</h1><p>2004年Eric Evans 发表《领域驱动设计——软件核心复杂性应对之道》（Domain-Driven Design –Tackling Complexity in the Heart of Software），简称Evans DDD，领域驱动设计思想进入软件开发者的视野。领域驱动设计分为两个阶段：</p>
<a id="more"></a>

<ul>
<li>1、以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型；</li>
<li>2、由领域模型驱动软件设计，用代码来实现该领域模型；</li>
</ul>
<p>简单地说，软件开发不是一蹴而就的事情，我们不可能在不了解产品（或行业领域）的前提下进行软件开发，在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。</p>
<img src="https://ae02.alicdn.com/kf/H7d8b5a375f014b28a6bec59cada27410N.png" alt="image.png" title="image.png" />



<h1 id="传统软件开发与贫血模型"><a href="#传统软件开发与贫血模型" class="headerlink" title="传统软件开发与贫血模型"></a>传统软件开发与贫血模型</h1><h2 id="传统的开发思想"><a href="#传统的开发思想" class="headerlink" title="传统的开发思想"></a>传统的开发思想</h2><p>传统开发四层架构</p>
<img src="https://ae01.alicdn.com/kf/H55424acf454442819ac955f164305dba6.png" alt="image.png" title="image.png" />

<p>在传统模型中，对象是数据的载体，只有简单的getter/setter方法，没有行为。以数据为中心，以数据库ER设计作驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。</p>
<p>以商家活动为例，首先设计数据库表配置</p>
<img src="https://ae01.alicdn.com/kf/Hf5866e365f1c42c0b473731fc7b1ecd9J.png" alt="image.png" title="image.png" />

<p>设计WmActPoi对象，只有简单的get和set属性方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WmActPoi</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String wmPoiId;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer startTime;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer endTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getWmPoiId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wmPoiId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> WmActPoiDB <span class="title">setWmPoiId</span><span class="params">(Integer wmPoiId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wmPoiId = wmPoiId;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service层代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WmActPoiService</span> </span>&#123;</span><br><span class="line">    saveWmActPoi();   <span class="comment">//保存活动</span></span><br><span class="line">    checkWmActPoi();   <span class="comment">//活动校验</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WmActPoiQueryService</span> </span>&#123;</span><br><span class="line">    queryWmActPoi();   <span class="comment">//查询活动</span></span><br><span class="line">    queryWmActPoiByWmPoiId();   <span class="comment">//根据门店查询活动</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，业务逻辑都是写在Service中的，WmActPoi充其量只是个数据载体，没有任何行为，是一种<strong>只有数据没有行为</strong>（<strong>只有数据没有行为</strong>）。<strong>简单的业务系统采用这种贫血模型和过程化设计是没有问题的，</strong>但在业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确，<strong>我们将这种情况称为由贫血症引起的失忆症</strong>。</p>
<img src="https://ae06.alicdn.com/kf/H5ff5fb60616c497bb570239bf31a7175t.png" alt="image.png" title="image.png" />

<p>传统架构的特点：</p>
<ul>
<li>a. 以数据库为中心</li>
<li>b. 贫血模型</li>
<li>c. 业务逻辑散落在大量的方法中</li>
<li>d. 当系统越来越复杂时，开发时间指数增长，维护成本很高</li>
</ul>
<h1 id="领域驱动模型的一些要素"><a href="#领域驱动模型的一些要素" class="headerlink" title="领域驱动模型的一些要素"></a>领域驱动模型的一些要素</h1><img src="https://ae05.alicdn.com/kf/Hf98fcbb3e4a74ff998a936a7d1115e7bD.png" alt="image.png" title="image.png" />

<h4 id="实体-Entity-amp-值对象-Value-Object"><a href="#实体-Entity-amp-值对象-Value-Object" class="headerlink" title="实体(Entity) &amp; 值对象(Value Object)"></a>实体(Entity) &amp; 值对象(Value Object)</h4><p><code>实体</code>与面向对象中的概念类似，在这里再次提出是因为它是领域模型的基本元素。在领域模型中，<strong>实体应该具有唯一的标识符</strong>，从设计的一开始就应该考虑实体，决定是否建立一个实体也是十分重要的。</p>
<p><code>值对象</code>和我们说的编程中数值类型的变量是不同的，它仅仅是<strong>没有唯一标识符的实体</strong>，比如有两个收获地址的信息完全一样，那它就是值对象，并不是实体。值对象在领域模型中是可以被共享的，他们应该是“不可变的”（只读的），当有其他地方需要用到值对象时，可以将它的副本作为参数传递。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
</search>
